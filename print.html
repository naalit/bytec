<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ByteC Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">2.</strong> Usage and Project Structure</a></li><li class="chapter-item expanded "><a href="language.html"><strong aria-hidden="true">3.</strong> Language Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">3.2.</strong> Classes and Enums</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">3.3.</strong> Modules</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">3.4.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="optimization.html"><strong aria-hidden="true">4.</strong> Optimization Features</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">5.</strong> Interacting with the Battlecode API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ByteC Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ByteC or <code>bytec</code> is a compiler from a tiny Rust-like language to bytecode-optimized Java, intended for use in Battlecode.</p>
<p>The language (also called &quot;bytec&quot; for lack of a better name) has a few features Java doesn't, like zero-overhead dynamic arrays, unrolled statically-sized arrays, and tuples, and it's fully interoperable with Java so it can be used for the performance-critical parts of a Java bot. The language itself is somewhere in between Rust and Java.</p>
<p>For an example of a Battlecode 2022 bot written in ByteC, see <a href="https://github.com/naalit/battlecode22">https://github.com/naalit/battlecode22</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-and-project-structure"><a class="header" href="#usage-and-project-structure">Usage and Project Structure</a></h1>
<p>ByteC can be installed by cloning this repository and then running <code>cargo install --path .</code> (you'll need Rust installed to use <code>cargo</code>); make sure you have cargo's output directory on your <code>PATH</code> (this is <code>~/.cargo/bin</code> on Linux). After that, you can use the <code>bytec</code> command to run the compiler.</p>
<p>The project structure for a ByteC-based Battlecode bot should look something like this (see an <a href="https://github.com/naalit/battlecode22">example Battlecode 2022 bot here</a>):</p>
<ul>
<li><code>battlecode22</code> - the Git repository for this year's bots, a clone of <code>battlecode22-scaffold</code>
<ul>
<li><code>bytec</code> - this is the directory that all ByteC source files go in; it would be called <code>src</code>, but that must be the output directory because it's hardcoded into the Battlecode engine.
<ul>
<li><code>common</code> - modules in here will be shared between all bots.
<ul>
<li><code>Common.bt</code></li>
<li><code>Paths.bt</code></li>
</ul>
</li>
<li><code>bot_one</code>
<ul>
<li><code>RobotPlayer.bt</code></li>
<li><code>Soldier.bt</code></li>
</ul>
</li>
<li><code>bot_two</code>
<ul>
<li><code>RobotPlayer.bt</code></li>
<li><code>Miner.bt</code></li>
</ul>
</li>
</ul>
</li>
<li><code>src</code> - output Java files must go in this directory to be seen by the Battlecode client. This is probably in <code>.gitignore</code> so you don't commit these files every time.
<ul>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Then, the CLI syntax for <code>bytec</code> looks like <code>bytec source-path1 source-path2... dest-path</code>, so here it would be:</p>
<pre><code>bytec bytec/common bytec/bot_one src/bot_one
</code></pre>
<p>This is intended to make it easy to test against alternate versions of your bot - simply compile to a certain output package (the names don't need to match, <code>bytec</code> will insert the necessary <code>package</code> declarations), make a change, and then compile it again to a different output package and run them against each other. The ability to override <a href="./constants.html">constants</a> from the command line (<code>-CModule::SOME_CONST=12</code>, along the lines of C's <code>-DSOME_CONST=12</code>) also helps with that, especially with scripts that might test many possible parameters automatically.</p>
<h2 id="vscode-extension"><a class="header" href="#vscode-extension">VSCode extension</a></h2>
<p>There's a VSCode extension for ByteC with syntax highlighting, errors as you type, and autocomplete for class members. The extension is not on the marketplace, unfortunately - to install it, you'll want to symlink the <code>vscode</code> folder at the top level of the <code>bytec</code> repository to <code>[VSCODE-DIRECTIORY]/extensions/bytec-basic</code> - the VSCode directory is <code>~/.vscode-oss</code> on Linux. The extension assumes you've installed bytec to <code>$HOME/.cargo/bin</code>, which is the default on Linux (and I think also on Mac?).</p>
<p>Alternatively, if you open the <code>bytec</code> repository in VSCode and then click F5 (or &quot;Launch Extension&quot; in the Run and Debug menu), it should open a new VSCode window with the extension loaded, without needing to install the extension manually - but you'd need to do that every time you use it, so actually installing the extension is preferred.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-tour"><a class="header" href="#language-tour">Language Tour</a></h1>
<p>ByteC is syntactically similar to Rust: functions are declared with <code>fn</code> and variables with <code>let</code> and type inference.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn triple(x: i32): i32 {
    let y = x + x;
    x + y // the last statement in a block is returned automatically
}
<span class="boring">}
</span></code></pre></pre>
<p>Functions and variables declared on the top-level of a module (a source file) turn into <code>static</code> members in Java.
Functions can be written in a single-expression style as well:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn triple2(x: i32): i32 = x * 3;
<span class="boring">}
</span></code></pre></pre>
<p>ByteC has a few &quot;primitive&quot; types, which should be familiar from Rust, along with <code>as</code> to convert between number types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: i32 = 12;
let b: i64 = 1300000000;
let c: str = &quot;Hello, world!&quot;;
let d: bool = false;
let e: () = {}; // The unit type, used for `void` functions
let f: f32 = 9.2;
let g: f64 = 0.9352891473 + a as f64;
<span class="boring">}
</span></code></pre></pre>
<p>As well as tuples, which don't yet support destructuring but do support member access with dot syntax. These are of course lowered to separate variables.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, i64) = (a, b);
a += tup.0;
b += tup.1;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>==</code> and <code>!=</code> operators are automatically translated to <code>.equals()</code> when comparing objects, as long as neither side is <code>null</code>;
so you can just compare everything with <code>==</code> and it should never cause problems unless you specifically need reference equality for some reason.
Other operators are the same as Java, except that bitwise operators all have the same precedence and you should really just be using parentheses for those anyway.</p>
<p>All variables are immutable by default, but they can be declared mutable using <code>let mut</code>, and can then be reassigned and modified in the normal way:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 3;
a += 2;
a = 4;
<span class="boring">}
</span></code></pre></pre>
<p>However, since ByteC compiles to Java, objects are always mutable - if you have an immutable <code>let</code> variable referring to an object, you can still reassign fields of the object, but you can't reassign the variable to point to a new object.</p>
<p><code>if-else</code> and <code>match</code> (the equivalent to Java <code>switch</code>) are expressions, and can return a value from each branch.
They don't require parentheses, but do require braces around the body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff(cond: bool, ty: RobotType): i32 {
    let a = if cond {
        // this is just a normal block, we can put statements here too
        let tmp = 12 + 3;
        tmp + 4
    } else {
        22
    };
    let b = match ty {
        ARCHON =&gt; 27,
        MINER =&gt; 2 + {
            // a block can be used in expression position
            // this variable is unrelated to the last one, blocks create their own scopes
            let tmp = 9 + 8;
            tmp * 2
        },
        // this is the `default` case
        // it's not necessary if we handle all possible variants
        else =&gt; 0,
    };
    a * b
}
<span class="boring">}
</span></code></pre></pre>
<p>Loops are not expressions, and there are about three types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The simplest kind of loop, loops infinitely until a `break`
let a = 0;
loop {
    a += 1;
    if a &gt; 12 {
        break;
    }
}

// A while loop, this is just like other procedural languages
while a &lt; 24 {
    a += 1;
}

// There are actually three kinds of four loop:
// A range for loop - this can be unrolled by adding the `unroll` keyword before the start of the range:
for i in 0..10 {
    a += i;
}
// A loop over a static array - this is guaranteed to be unrolled:
let sArr: [i32; 3] = [1, 2, 3];
for i in sArr {
    a += i;
}
// A loop over a dynamic array - this is never unrolled:
let dArr: [i32] = [1, 2, 3];
for i in dArr {
    a += i;
}
<span class="boring">}
</span></code></pre></pre>
<p>ByteC does have <code>null</code>, which is a possible value of classes, enums, and strings (but not either kind of array).
There are currently no optional types or any type safety regarding <code>null</code>.
<code>null</code> is usually inferred as the correct type, but in some cases the compiler can't figure this out and a construction like this is needed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn getMapLocation(): MapLocation {
    let n: MapLocation = null;
    n
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>The two types of arrays, static and dynamic, are a concept that doesn't exist in Java so they deserve some explanation.
A static array has a constant length known at compile time, and it becomes a bunch of separate variables in Java.
Any loop over a static array is unrolled, and indexing the array must either use an index that the compiler can figure out is constant, or use the <code>inline</code> keyword to be turned into a <code>switch</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [i32; 16];
fn getArr(i: i32): i32 {
    arr[inline i]
}
<span class="boring">}
</span></code></pre></pre>
<p>A dynamic array, on the other hand, doesn't have a length known at compile time. In fact, the length of the array can change at any moment.
It's similar to a Java <code>ArrayList</code>, but all the logic is inlined, so any operations that normal Java arrays support (indexing, index assignment, looping over the array) are exactly as fast, and <code>push</code> and <code>pop</code> are pretty fast as well and don't involve method calls. Java arrays returned by <code>extern</code> functions are automatically converted to ByteC dynamic arrays. (Internally, dynamic arrays are represented as a Java array, which might have open space at the end, and a length.) Here's an example of the operations supported by dynamic arrays:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This initializes an array of five zeros
let x: [i32] = [; 5];

// The length of the array can be accessed with .len(); there is currently no way to access the capacity.
// This is also supported by static arrays
println(&quot;length: &quot; + x.len());

// Note that there isn't actually bounds checking in array indexes for performance
// So if ByteC has allocated 8 elements but the length of the array is only 5, accessing x[6] has an undefined result
// (in practice it will return 0 or the last element to occupy that slot, or throw an exception if the space isn't allocated)
x[0] = 2;
let y = x[4];

// adds 12 to the end of the array, reallocating if there isn't enough space
x.push(12);

// pops the last element off the end of the array, leaving the space to be used by future push() calls
let twelve = x.pop();

// clears all elements from the array, setting the length to 0 and leaving the capacity allocated
// note that this only costs 2 bytecode, no matter the array capacity!
x.clear();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-and-enums"><a class="header" href="#classes-and-enums">Classes and Enums</a></h1>
<p>Classes in bytec (which aren't marked <code>extern</code> - we'll cover <code>extern</code> classes in the Java interop section) are pretty simple. They can have fields and methods, but custom constructors aren't yet supported (and neither are static members).</p>
<pre><code class="language-rs">class LocInfo {
    let loc: MapLocation;
    let rubble: i32;
    // Fields can have an initial value, but must have an explicit type
    let score: i32 = 0;

    fn set(loc: MapLocation) throws GameActionException {
        self.loc = loc;
        self.rubble = rc.senseRubble(loc);
    }
}
let x = LocInfo();
x.set(rc.getLocation());
</code></pre>
<p>Enums are a little further from Java enums, and closer to Rust ones. Each variant can have members, which essentially form a tuple:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Action {
    Attack(RobotInfo),
    Envision(AnomalyType),
    Move(Direction),
    Disintegrate;

    fn isGood(): bool {
        match self {
            Disintegrate =&gt; false,
            Envision(a) =&gt; a != AnomalyType::FURY || !isFriendlyArchonInRange(),
            _ =&gt; true,
        }
    }
}
let toTake = Action::Move(Direction::NORTH);
if toTake.isGood() {
    rc.move(Direction::NORTH);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Using multiple source files (&quot;modules&quot;) is generally a good idea. In ByteC, the directory that files are in doesn't matter, only the file name.
Circular dependencies are allowed (at least, <em>almost</em> all the time).
Items from other files can be accessed with <code>use</code> or with <code>::</code>, the same as Rust:</p>
<pre><pre class="playground"><code class="language-rust">// One.bt
let one = 1;
fn main() = Two::doStuff();
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Two.bt
use One::one; // One::* would also work
extern fn println(x: str) = &quot;System.out.println&quot;;
fn doStuff() {
    println(&quot;two: &quot; + (one + one));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constants replace the old C-like system of <code>define</code>s that <code>bytec</code> used until Battlecode 2023, and are much easier to use (for instance, they're scoped like all other items!). They look like <code>let</code> definitions, but using <code>const</code> instead of <code>let</code>. The constant value is always inlined into use sites - this is the difference between a top-level <code>let</code> and <code>const</code>.</p>
<p><strong>Warning!</strong> The value of a constant is essentially pasted at every use. Generally, a constant should have a value that is known at compile time; otherwise, it may be worse than it looks for performance, as the value is evaluated multiple times (just use <code>let</code> instead if computation is involved). Additionally, something like <code>const C = getCurrentTime()</code> is possible, and would have a different value each time it is used, which though convenient is not easily visible. Eventually the compiler is intended to check that constants have compile-time known values, but this has not yet been implemented, so be careful.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Main.bt
const SOME_FLAG = true;
const SOME_CONST = 12;

fn someFunction() {
    // This if will disappear, since the value of SOME_FLAG is known at compile time
    if SOME_FLAG {
        // SOME_CONST will be replaced with the value 12 during compilation
        println(&quot;SOME_CONST = &quot; + SOME_CONST);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also override constants from the command line with <code>-C&lt;module&gt;::&lt;constant&gt;=&lt;value&gt;</code> - for this example: <code>-CMain::SOME_FLAG=false -CMain::SOME_CONST=42</code>. (This is an analogue of C's <code>-DSOME_CONST=52</code>.)
This can be useful for testing different magic numbers and features in a systematic way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimization-features"><a class="header" href="#optimization-features">Optimization Features</a></h1>
<p>The primary purpose of ByteC is to enable high-level, maintanable programming that preserves maximum bytecode efficiency.
To that end, it has a few features designed specifically for this.</p>
<h2 id="unrolled-loops"><a class="header" href="#unrolled-loops">Unrolled loops</a></h2>
<p>Statically sized arrays were briefly mentioned in the language tour, but it's worth explaining them in more detail here.
An array that looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [i32; 3] = [1, 2, 3];
arr[1] += 1;
for i in arr {
    println(&quot;i = &quot; + i);
}
<span class="boring">}
</span></code></pre></pre>
<p>Will generate Java code like this:</p>
<pre><code class="language-java">static int arr$0 = 1;
static int arr$1 = 2;
static int arr$2 = 3;

arr$1 += 1;

System.out.println(&quot;i = &quot; + arr$0);
System.out.println(&quot;i = &quot; + arr$1);
System.out.println(&quot;i = &quot; + arr$2);
</code></pre>
<p>You can also unroll range for loops with the <code>unroll</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in unroll 0..3 {
    arr[i] += i;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that you can index static arrays with any expression that the compiler can figure out at compile time. For example, this reduces to a bunch of one-line assignments to local variables, and the indices and if statements are all resolved at compile time:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cache: [i32; 81];

for x in unroll -4..5 {
    for y in unroll -4..5 {
        if x*x + y*y &lt;= 20 {
            let i = (x + 4) * 9 + y + 4;
            cache[i] = rc.senseRubble(MapLocation(at.x + x, at.y + y));
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, indexing static arrays by non-constant expressions is an error (although the message isn't very helpful yet in this case).
If you really want to generate a <code>switch</code> over all possible indices, you can do that with the <code>inline</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tx = target.x - at.x;
let ty = target.y - at.y;
if tx*tx + ty*ty &lt;= 20 {
    let i = (tx + 4) * 9 + ty + 4;
    return cache[inline i];
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that these <code>inline</code> index expressions are currently not supported on the left-hand-side of an assignment, i.e. <code>cache[inline i] = 12;</code> doesn't work.</p>
<h2 id="inline-functions"><a class="header" href="#inline-functions">Inline functions</a></h2>
<p>You can mark functions <code>inline</code> to make the compiler inline them:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inline manhattanDistance(a: MapLocation, b: MapLocation): i32 {
    abs(a.x - b.x) + abs(a.y - b.y)
}
<span class="boring">}
</span></code></pre></pre>
<p>If the arguments are constant, they will be propagated throughout the function body, so you can e.g. access static arrays with indices that depend on the function arguments as long as the function is only ever called with constant arguments (e.g. in unrolled loops is fine).</p>
<p><strong>Warning!</strong> <code>return</code> has strange behavior in inline functions. Specifically, the type checker treats it as if it's returning from the inline function, but it will actually return from the enclosing function. Usually getting this wrong results in a type error either in ByteC or the Java compiler, but it's important to keep in mind especially with <code>()</code>-returning functions. Please don't rely on this behavior, as it will hopefully be fixed in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-the-battlecode-api"><a class="header" href="#interacting-with-the-battlecode-api">Interacting with the Battlecode API</a></h1>
<h2 id="overview-of-java-interop-in-general"><a class="header" href="#overview-of-java-interop-in-general">Overview of Java interop in general</a></h2>
<p>Java interop is done with the <code>extern</code> keyword, which can be used in many contexts with roughly the same meaning of &quot;the thing following this is a Java thing&quot;.
The simplest way is <code>extern</code> blocks, which can be at the top level (e.g. for imports) or in blocks, and can be multiline with braces or single line with quotes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern {
    import battlecode.common.*;
}

fn doStuff() {
    extern &quot;System.out.print(\&quot;Hello, \&quot;);&quot;;
    extern {
        System.out.println(&quot;world!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can mark almost any ByteC name as <code>pub</code> to make it visible from Java, as long as it has a type that exists in Java:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pub makeGreeting(x: str): str = &quot;Hello, &quot; + x;
fn greet(pub name: str) {
    extern {
        String greeting = makeGreeting(name);
        System.out.println(greeting);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, actually writing inline Java code is very rarely necessary. Usually, you'll define the Java API to interact with and then interact with it.
This uses <code>extern</code> classes, enums, and functions, which are generally written just like their non-<code>extern</code> variants, but without function bodies. There's also the <code>constructor</code> keyword for class constructor prototypes, although only one can be used for a given class. The names of extern functions can be changed by adding an <code>= &quot;&lt;name&gt;&quot;</code>, which is especially important for static methods and overloading (neither of which is natively supported by ByteC).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern class MapLocation {
    constructor(x: i32, y: i32);
    let x: i32;
    let y: i32;

    fn add(dir: Direction): MapLocation;
    fn distanceSquaredTo(loc: MapLocation): i32;
}

extern enum RobotType {
    ARCHON,
    BUILDER,
    LABORATORY,
    MINER,
    SAGE,
    SOLDIER,
    WATCHTOWER;

    let damage: i32;
    let health: i32;

    fn canAttack(): bool;
    fn canMine(): bool;
}

extern fn bytecodeNum(): i32 = &quot;Clock.getBytecodeNum&quot;;
<span class="boring">}
</span></code></pre></pre>
<h2 id="interacting-with-the-battlecode-api-1"><a class="header" href="#interacting-with-the-battlecode-api-1">Interacting with the Battlecode API</a></h2>
<p>You'll need to use the Battlecode API to do anything useful, and unfortunately this is a little bit harder than in Java, because ByteC isn't smart enough to find and read the API by itself. You'll probably have a file called something like <code>Common.bt</code> or <code>API.bt</code> shared by all your bots, which has a bunch of <code>extern</code> declarations for the entire Battlecode API - an example is at the end of this page. My API bindings were 300 lines of code in 2022, and automatically generating this from the Javadoc isn't too hard; I may write a dedicated script to do this and include it with ByteC at some point.</p>
<p>Also, most functions will probably require <code>throws GameActionException</code>. The <code>throws</code> clause is actually entirely ignored by ByteC and just passed on to the Java code, but the Java compiler will complain if you leave these out (that does mean you don't need them for inline functions, though).</p>
<p>You'll also need the RobotPlayer class, but this is actually easier than in Java, since every ByteC file (&quot;module&quot;) turns into a Java class with static members. Just make sure you have a file called <code>RobotPlayer.bt</code>, with something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern {
    import battlecode.common.*;
}

use Common::*;

let rc: RobotController;

// This turns into a static function in Java.
// Don't forget the `pub`, it's necessary for Java code to access this function!
fn pub run(rc2: RobotController) {
    rc = rc2;
    loop {
        extern &quot;try {&quot;;

        match rc.getType() {
            ARCHON =&gt; Archon::turn(),
            MINER =&gt; Miner::turn(),
            SOLDIER =&gt; Soldier::turn(),
            BUILDER =&gt; Builder::turn(),
            WATCHTOWER =&gt; Watchtower::turn(),
            SAGE =&gt; Sage::turn(),
            LABORATORY =&gt; Laboratory::turn(),
        }

        extern &quot;} catch (Exception e) { e.printStackTrace(); }&quot;;

        clockYield();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Some of the API binding code that corresponds to this example would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern {
    import battlecode.common.*;
}

extern fn clockYield() = &quot;Clock.yield&quot;;
extern fn bytecodeNum(): i32 = &quot;Clock.getBytecodeNum&quot;;
extern fn bytecodeLeft(): i32 = &quot;Clock.getBytecodesLeft&quot;;

extern enum RobotType {
    ARCHON,
    BUILDER,
    LABORATORY,
    MINER,
    SAGE,
    SOLDIER,
    WATCHTOWER;

    let actionCooldown: i32;
    let actionRadiusSquared: i32;
    let buildCostGold: i32;
    let buildCostLead: i32;
    let bytecodeLimit: i32;
    let damage: i32;
    let health: i32;
    let movementCooldown: i32;
    let visionRadiusSquared: i32;

    fn canAttack(): bool;
    fn canMine(): bool;
    fn canBuild(t: RobotType): bool;
    fn canRepair(t: RobotType): bool;
    fn canMutate(t: RobotType): bool;
    fn isBuilding(): bool;

    // etc.
}
extern class MapLocation {
    constructor(x: i32, y: i32);
    let x: i32;
    let y: i32;

    fn add(dir: Direction): MapLocation;
    fn subtract(dir: Direction): MapLocation;
    fn directionTo(loc: MapLocation): Direction;
    fn distanceSquaredTo(loc: MapLocation): i32;
    fn isWithinDistanceSquared(loc: MapLocation, distanceSquared: i32): bool;
    fn translate(dx: i32, dy: i32): MapLocation;
    fn isAdjacentTo(loc: MapLocation): bool;    
}
extern class RobotController {
    // Returns the location adjacent to current location in the given direction.
    fn adjacentLocation(dir: Direction): MapLocation;

    // Attack a given location.
    fn attack(loc: MapLocation);

    // Builds a robot of the given type in the given direction.
    fn buildRobot(type: RobotType, dir: Direction);

    // Note that ByteC doesn't support overloading, so these functions need to have different names but map to the same Java function.

    // Returns all robots within vision radius.
    fn senseNearbyRobots(): [RobotInfo];
    // Returns all robots that can be sensed within a certain distance of this robot.
    fn senseNearbyRobotsR(radiusSquared: i32): [RobotInfo] = &quot;senseNearbyRobots&quot;;
    // Returns all robots of a given team that can be sensed within a certain distance of this robot.
    fn senseNearbyRobotsT(radiusSquared: i32, team: Team): [RobotInfo] = &quot;senseNearbyRobots&quot;;
    // Returns all robots of a given team that can be sensed within a certain radius of a specified location.
    fn senseNearbyRobotsAt(center: MapLocation, radiusSquared: i32, team: Team): [RobotInfo] = &quot;senseNearbyRobots&quot;;

    // etc.
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
